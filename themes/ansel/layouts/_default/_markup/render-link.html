{{ $link := strings.Replace .Destination "_index.md" "" }}
{{ $isRemote := strings.HasPrefix $link "http" }}
{{- if not $isRemote -}}
  {{ $url := urls.Parse $link }}
  {{- if $url.Path -}}
    {{ $fragment := printf "#%s" $url.Fragment }}
    {{- with .Page.GetPage $url.Path -}}
      {{ $link = printf "%s%s" .RelPermalink $fragment }}
    {{ else }}
      {{- /* Hugo couldn't find the page. Typically because it's a relative path like
          `../../../stuff.md`. In that case, remove `.md` and hope the browser
          supports relative pathes to resolve the URL.
          In an ideal world, we split the path at `/` and go up the tree by as
          many elements, but we don't have access to the calling file from here */ -}}
      {{- /* $tree := split $url.Path "/" */ -}}
      {{ $link = strings.Replace $link ".md" "/" }}
      {{- /* Because ../../stuff.md will be interpreted as ../../stuff/index.html after
          compilation, relative links need to go one step higher to resolve properly */ -}}
      {{ if strings.HasPrefix $link "../" }}
        {{ $link = printf "../%s" $link }}
      {{ end }}
    {{- end -}}
  {{- end -}}
{{- end -}}
<a href="{{ $link | safeURL }}" title="{{ .Title | safeHTML }}" {{ if $isRemote }} target="_blank"{{ end }}>{{ .Text | safeHTML }}</a>
